mod world_edit12;
mod world_edit13;
mod litematica;

mod vanilla_structure;
mod mc_version;

//mod schem {
use std::collections::HashMap;
use ndarray::Array3;
use crate::block::{Block, CommonBlock};
use fastnbt;
use crate::schem::schem::MetaData::Litematica;
//use schem::mc_version;
use crate::schem;
use crate::error;

#[derive(Debug)]
pub struct BlockEntity {
    pub tags: HashMap<String, fastnbt::Value>,
}

impl BlockEntity {
    pub fn new() -> BlockEntity {
        return BlockEntity {
            tags: HashMap::new(),
        };
    }
}

#[derive(Debug)]
pub struct Entity {
    pub tags: HashMap<String, fastnbt::Value>,
    pub position: [f64; 3],
    pub block_pos: [i32; 3],
}

impl Entity {
    pub fn new() -> Entity {
        return Entity {
            tags: HashMap::new(),
            position: [0.0, 0.0, 0.0],
            block_pos: [0, 0, 0],
        };
    }
}

#[derive(Debug)]
pub struct Region {
    pub name: String,
    pub array: Array3<u16>,
    //XYZ
    pub palette: Vec<Block>,
    pub block_entities: HashMap<[i64; 3], BlockEntity>,
    pub entities: Vec<Entity>,

    pub offset: [i64; 3],
}

impl Region {
    pub fn new() -> Region {
        return Region {
            name: String::from("NewRegion"),
            array: Array3::zeros([1, 1, 1]),
            palette: Vec::new(),
            block_entities: HashMap::new(),
            entities: Vec::new(),
            offset: [0, 0, 0],
        };
    }

    pub fn reshape(&mut self, size: [i64; 3]) {
        let mut usz: [usize; 3] = [0, 0, 0];
        for idx in 0..3 {
            let sz = size[idx];
            if sz < 0 {
                panic!("Try resizing with negative size [{},{},{}]", size[0], size[1], size[2]);
            }
            usz[idx] = sz as usize;
        }
        self.array = Array3::zeros(usz);
    }
    pub fn shape(&self) -> [i64; 3] {
        let shape = self.array.shape();
        if shape.len() != 3 {
            panic!("Invalid array dimensions: should be 3 but now it is {}", shape.len());
        }
        return [shape[0] as i64, shape[1] as i64, shape[2] as i64];
    }
    pub fn contains_coord(&self, coord: [i64; 3]) -> bool {
        for dim in 0..3 {
            if coord[dim] >= 0 && coord[dim] <= self.shape()[dim] {
                continue;
            }
            return false;
        }
        return true;
    }
    pub fn block_at(&self, coord: [i64; 3]) -> Option<&Block> {
        if !self.contains_coord(coord) {
            return None;
        }

        let x = coord[0] as usize;
        let y = coord[1] as usize;
        let z = coord[2] as usize;

        let pid = self.array[[x, y, z]] as usize;
        return Some(&self.palette[pid]);
    }
}

#[derive(Debug)]
pub struct LitematicaMetaData {
    pub version: i32,

    pub time_created: i64,
    pub time_modified: i64,
    pub author: String,
    pub name: String,
    pub description: String,
    pub total_volume: i64,
}

impl LitematicaMetaData {
    pub fn new() -> LitematicaMetaData {
        return LitematicaMetaData {
            version: 5,
            time_created: 0,
            time_modified: 0,
            author: String::from("mc_schem.rs"),
            name: String::from("Default litematica"),
            description: String::from("Default litematica generated by mc_schem.rs"),
            total_volume: 0,
        };
    }
}

#[derive(Debug)]
pub struct WE12MetaData {}

impl WE12MetaData {
    pub fn new() -> WE12MetaData {
        return WE12MetaData {};
    }
}

#[derive(Debug)]
pub struct WE13MetaData {
    pub version: i32,
    pub we_offset: [i32; 3],
    pub offset: [i32; 3],
}

impl WE13MetaData {
    pub fn new() -> WE13MetaData {
        return WE13MetaData {
            version: 5,
            we_offset: [0, 0, 0],
            offset: [0, 0, 0],
        };
    }
}

#[derive(Debug)]
pub struct VanillaStructureMetaData {}

impl VanillaStructureMetaData {
    pub fn new() -> VanillaStructureMetaData {
        return VanillaStructureMetaData {};
    }
}

#[derive(Debug)]
pub enum MetaData {
    Litematica(LitematicaMetaData),
    WE12(WE12MetaData),
    WE13(WE13MetaData),
    VanillaStructure(VanillaStructureMetaData),
}

#[derive(Debug)]
pub struct Schematic {
    pub data_version: i32,

    pub metadata: MetaData,

    pub regions: Vec<Region>,
    pub enclosing_size: [i64; 3],
}


// enum SchemFormat {
//     Litematica,
//     WorldEdit12,
//     WorldEdit13,
//     VanillaStructure,
// }
impl Schematic {
    pub fn new() -> Schematic {
        return Schematic {
            data_version: mc_version::DataVersion::new() as i32,
            metadata: Litematica(LitematicaMetaData::new()),
            regions: Vec::new(),
            enclosing_size: [1, 1, 1],
        };
    }
}

pub fn id_of_nbt_tag(tag: &fastnbt::Value) -> u8 {
    return match tag {
        fastnbt::Value::Byte(_) => 1,
        fastnbt::Value::Short(_) => 2,
        fastnbt::Value::Int(_) => 3,
        fastnbt::Value::Long(_) => 4,
        fastnbt::Value::Float(_) => 5,
        fastnbt::Value::Double(_) => 6,
        fastnbt::Value::ByteArray(_) => 7,
        fastnbt::Value::String(_) => 8,
        fastnbt::Value::List(_) => 9,
        fastnbt::Value::Compound(_) => 10,
        fastnbt::Value::IntArray(_) => 11,
        fastnbt::Value::LongArray(_) => 12,
    }
}


pub struct VanillaStructureLoadOption {
    pub background_block: CommonBlock,
}

impl VanillaStructureLoadOption {
    pub fn default() -> VanillaStructureLoadOption {
        return VanillaStructureLoadOption {
            background_block: CommonBlock::StructureVoid
        }
    }
}

pub struct VanillaStructureSaveOption {
    pub keep_air: bool,
}

impl VanillaStructureSaveOption {
    pub fn default() -> VanillaStructureSaveOption {
        return VanillaStructureSaveOption {
            keep_air: true
        }
    }
}